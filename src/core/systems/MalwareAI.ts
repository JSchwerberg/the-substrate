/**
 * Malware AI System - controls malware behavior and state transitions
 */

import { Grid, GridPosition, getTile, isWalkable, getManhattanDistance } from '../models/grid'
import {
  Malware,
  getMalwareHealthPercent,
  activateMalware,
  tickMalwareCooldown,
  canUseAbility,
  useAbility,
} from '../models/malware'
import { Process, applyDamage as applyDamageToProcess, getEffectiveStat } from '../models/process'
import { applyDamageToMalware } from '../models/malware'
import { findPath } from './Pathfinding'
import { calculateDamage } from './CombatSystem'

// ============= Game State Interface =============

/**
 * Minimal game state interface for AI operations
 * Replaces Expedition dependency with concrete properties
 */
export interface GameState {
  grid: Grid
  processes: Map<string, Process>
  malware: Map<string, Malware>
}

/**
 * Get alive processes from game state
 */
function getAliveProcesses(state: GameState): Process[] {
  return Array.from(state.processes.values()).filter(p => p.status !== 'destroyed')
}

/**
 * Get processes within range of a position
 */
function getProcessesInRange(state: GameState, position: GridPosition, range: number): Process[] {
  return getAliveProcesses(state).filter(p => {
    const dx = Math.abs(p.position.x - position.x)
    const dy = Math.abs(p.position.y - position.y)
    return dx + dy <= range
  })
}

/**
 * Get malware at a specific position
 */
function getMalwareAt(state: GameState, position: GridPosition): Malware | null {
  for (const malware of state.malware.values()) {
    if (malware.position.x === position.x && malware.position.y === position.y) {
      return malware
    }
  }
  return null
}

/**
 * Get alive malware within range (for area attacks)
 */
function getAliveMalware(state: GameState): Malware[] {
  return Array.from(state.malware.values()).filter(m => m.status !== 'destroyed')
}

/**
 * Get malware within range of a position
 */
function getMalwareInRange(state: GameState, position: GridPosition, range: number): Malware[] {
  return getAliveMalware(state).filter(m => {
    const dx = Math.abs(m.position.x - position.x)
    const dy = Math.abs(m.position.y - position.y)
    return dx + dy <= range
  })
}

/**
 * Apply area damage effect without logging (for GameState compatibility)
 */
function applyAreaDamage(
  attacker: { attack: number; type: 'process' | 'malware' },
  center: GridPosition,
  radius: number,
  state: GameState
): void {
  if (attacker.type === 'malware') {
    // Malware AoE hits processes
    const targets = getProcessesInRange(state, center, radius)
    for (const target of targets) {
      const damage = calculateDamage(attacker.attack, getEffectiveStat(target, 'defense'))
      applyDamageToProcess(target, damage)
    }
  } else {
    // Process AoE hits malware
    const targets = getMalwareInRange(state, center, radius)
    for (const target of targets) {
      const damage = calculateDamage(attacker.attack, target.stats.defense)
      applyDamageToMalware(target, damage)
    }
  }
}

// ============= AI Decision Making =============

export interface AIDecision {
  action: 'idle' | 'move' | 'attack' | 'flee' | 'ability'
  target?: GridPosition
  targetId?: string
}

/**
 * Determine the next action for a malware entity
 */
export function decideMalwareAction(malware: Malware, state: GameState): AIDecision {
  // Dormant malware don't act
  if (malware.status === 'dormant') {
    // Check if a process is adjacent to wake up
    const nearbyProcesses = getProcessesInRange(state, malware.position, 1)
    if (nearbyProcesses.length > 0) {
      activateMalware(malware)
    }
    return { action: 'idle' }
  }

  // Destroyed malware don't act
  if (malware.status === 'destroyed') {
    return { action: 'idle' }
  }

  // Check for flee condition
  const healthPercent = getMalwareHealthPercent(malware)
  if (healthPercent <= malware.behavior.fleeHealthPercent) {
    malware.status = 'fleeing'
    const fleeTarget = findFleePosition(malware, state)
    if (fleeTarget) {
      return { action: 'flee', target: fleeTarget }
    }
  }

  // Check for processes in aggro range
  const inAggroRange = getProcessesInRange(state, malware.position, malware.behavior.aggroRange)

  if (inAggroRange.length > 0) {
    // Become alerted if not already
    if (malware.status !== 'alerted') {
      malware.status = 'alerted'
    }

    // Check for ability use
    if (canUseAbility(malware) && malware.behavior.specialAbility) {
      const abilityDecision = decideAbilityUse(malware, state, inAggroRange)
      if (abilityDecision) {
        return abilityDecision
      }
    }

    // Find target based on preference
    const target = selectTarget(malware, inAggroRange)

    // If adjacent, attack
    const distance = getManhattanDistance(malware.position, target.position)
    if (distance <= 1) {
      return { action: 'attack', targetId: target.id }
    }

    // If mobile, move toward target
    if (malware.stats.speed > 0) {
      return { action: 'move', target: target.position, targetId: target.id }
    }
  } else {
    // No targets in range, become active (not alerted)
    if (malware.status === 'alerted') {
      malware.status = 'active'
    }
  }

  return { action: 'idle' }
}

/**
 * Select a target based on malware's preferred target type
 */
function selectTarget(malware: Malware, candidates: Process[]): Process {
  if (candidates.length === 1) return candidates[0]!

  switch (malware.behavior.preferredTarget) {
    case 'nearest':
      return candidates.reduce((a, b) =>
        getManhattanDistance(malware.position, a.position) <
        getManhattanDistance(malware.position, b.position)
          ? a
          : b
      )

    case 'weakest':
      return candidates.reduce((a, b) => (a.stats.health < b.stats.health ? a : b))

    case 'strongest':
      return candidates.reduce((a, b) => (a.stats.health > b.stats.health ? a : b))

    case 'random':
      return candidates[Math.floor(Math.random() * candidates.length)]!

    default:
      return candidates[0]!
  }
}

/**
 * Find a position to flee to (away from threats)
 */
function findFleePosition(malware: Malware, state: GameState): GridPosition | null {
  const threats = getAliveProcesses(state)
  if (threats.length === 0) return null

  // Calculate average threat position
  let avgX = 0
  let avgY = 0
  for (const threat of threats) {
    avgX += threat.position.x
    avgY += threat.position.y
  }
  avgX = Math.floor(avgX / threats.length)
  avgY = Math.floor(avgY / threats.length)

  // Find direction away from threats
  const dx = malware.position.x - avgX
  const dy = malware.position.y - avgY

  // Try to move in that direction
  const candidates = [
    { x: malware.position.x + Math.sign(dx), y: malware.position.y },
    { x: malware.position.x, y: malware.position.y + Math.sign(dy) },
    { x: malware.position.x + Math.sign(dx), y: malware.position.y + Math.sign(dy) },
  ]

  for (const pos of candidates) {
    const tile = getTile(state.grid, pos)
    if (tile && isWalkable(tile) && !getMalwareAt(state, pos)) {
      return pos
    }
  }

  return null
}

/**
 * Decide whether to use a special ability
 */
function decideAbilityUse(
  malware: Malware,
  _state: GameState,
  targets: Process[]
): AIDecision | null {
  const ability = malware.behavior.specialAbility
  if (!ability) return null

  switch (ability.effect) {
    case 'replicate':
      // Worms replicate when they have enough targets
      if (targets.length >= 2) {
        return { action: 'ability' }
      }
      break

    case 'explode': {
      // Logic bombs explode when adjacent to a process
      const adjacent = targets.filter(t => getManhattanDistance(malware.position, t.position) <= 1)
      if (adjacent.length > 0) {
        return { action: 'ability' }
      }
      break
    }

    case 'corrupt_tile':
      // Rootkits corrupt tiles periodically
      return { action: 'ability' }

    case 'stealth':
      // Re-stealth when damaged
      if (getMalwareHealthPercent(malware) < 80) {
        return { action: 'ability' }
      }
      break

    case 'entangle': {
      // Trojans entangle adjacent targets
      const adjacentTargets = targets.filter(
        t => getManhattanDistance(malware.position, t.position) <= 1
      )
      if (adjacentTargets.length > 0) {
        return { action: 'ability', targetId: adjacentTargets[0]!.id }
      }
      break
    }
  }

  return null
}

// ============= AI Execution =============

/**
 * Execute the AI decision for a malware entity
 */
export function executeMalwareAI(malware: Malware, state: GameState): void {
  // Tick cooldowns
  tickMalwareCooldown(malware)

  const decision = decideMalwareAction(malware, state)

  switch (decision.action) {
    case 'move':
      if (decision.target && malware.stats.speed > 0) {
        moveMalwareToward(malware, decision.target, state)
      }
      break

    case 'ability':
      executeAbility(malware, state, decision.targetId)
      break

    // Attack is handled by CombatSystem
    // Flee movement is handled like regular movement
    case 'flee':
      if (decision.target && malware.stats.speed > 0) {
        moveMalwareToward(malware, decision.target, state)
      }
      break
  }
}

/**
 * Move malware one step toward a target
 */
function moveMalwareToward(malware: Malware, target: GridPosition, state: GameState): boolean {
  const path = findPath(state.grid, malware.position, target)

  if (!path || path.length < 2) return false

  const nextPos = path[1]!
  const tile = getTile(state.grid, nextPos)

  if (!tile || !isWalkable(tile)) return false

  // Check for collision with other malware
  if (getMalwareAt(state, nextPos)) return false

  malware.position = { ...nextPos }
  return true
}

/**
 * Execute a malware's special ability
 */
function executeAbility(malware: Malware, state: GameState, targetId?: string): void {
  const ability = malware.behavior.specialAbility
  if (!ability || !canUseAbility(malware)) return

  switch (ability.effect) {
    case 'replicate':
      replicateMalware(malware, state)
      break

    case 'explode':
      explodeMalware(malware, state, ability.value)
      break

    case 'corrupt_tile':
      corruptNearbyTile(malware, state, ability.value)
      break

    case 'entangle':
      if (targetId) {
        entangleTarget(malware, state, targetId, ability.value)
      }
      break

    case 'stealth':
      malware.isRevealed = false
      break
  }

  useAbility(malware)
}

function replicateMalware(malware: Malware, state: GameState): void {
  // Find empty adjacent tile
  const offsets = [
    { x: -1, y: 0 },
    { x: 1, y: 0 },
    { x: 0, y: -1 },
    { x: 0, y: 1 },
  ]

  for (const offset of offsets) {
    const pos = {
      x: malware.position.x + offset.x,
      y: malware.position.y + offset.y,
    }

    const tile = getTile(state.grid, pos)
    if (!tile || !isWalkable(tile)) continue
    if (getMalwareAt(state, pos)) continue

    // TODO: Create new malware at this position
    // For now just log the attempt
    return
  }

  // No valid position found
}

function explodeMalware(malware: Malware, state: GameState, radius: number): void {
  applyAreaDamage(
    { type: 'malware', attack: malware.stats.attack },
    malware.position,
    radius,
    state
  )

  // Logic bomb destroys itself
  malware.status = 'destroyed'
  malware.stats.health = 0
}

function corruptNearbyTile(malware: Malware, state: GameState, amount: number): void {
  const offsets = [
    { x: -1, y: 0 },
    { x: 1, y: 0 },
    { x: 0, y: -1 },
    { x: 0, y: 1 },
  ]

  // Pick random adjacent tile
  const offset = offsets[Math.floor(Math.random() * offsets.length)]!
  const pos = {
    x: malware.position.x + offset.x,
    y: malware.position.y + offset.y,
  }

  const tile = getTile(state.grid, pos)
  if (!tile || tile.type === 'blocked') return

  tile.corruptionLevel = Math.min(100, tile.corruptionLevel + amount)
}

function entangleTarget(
  malware: Malware,
  state: GameState,
  targetId: string,
  duration: number
): void {
  const target = state.processes.get(targetId)
  if (!target) return

  target.statusEffects.push({
    id: `entangle-${malware.id}`,
    name: 'Entangled',
    type: 'debuff',
    duration,
    statModifiers: {
      speed: -target.stats.speed, // Can't move
    },
  })
}

// ============= Batch AI Processing =============

/**
 * Process AI for all malware in game state
 */
export function processAllMalwareAI(state: GameState): void {
  for (const malware of state.malware.values()) {
    if (malware.status !== 'destroyed') {
      executeMalwareAI(malware, state)
    }
  }
}
