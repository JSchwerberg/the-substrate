/**
 * Malware AI System - controls malware behavior and state transitions
 */

import { GridPosition, getTile, isWalkable, getManhattanDistance } from '../models/grid'
import {
  Malware,
  getMalwareHealthPercent,
  activateMalware,
  tickMalwareCooldown,
  canUseAbility,
  useAbility,
} from '../models/malware'
import {
  Expedition,
  getProcessesInRange,
  getAliveProcesses,
  getMalwareAt,
  logEvent,
} from '../models/expedition'
import { Process } from '../models/process'
import { findPath } from './Pathfinding'
import { areaAttack } from './CombatSystem'

// ============= AI Decision Making =============

export interface AIDecision {
  action: 'idle' | 'move' | 'attack' | 'flee' | 'ability'
  target?: GridPosition
  targetId?: string
}

/**
 * Determine the next action for a malware entity
 */
export function decideMalwareAction(
  malware: Malware,
  expedition: Expedition
): AIDecision {
  // Dormant malware don't act
  if (malware.status === 'dormant') {
    // Check if a process is adjacent to wake up
    const nearbyProcesses = getProcessesInRange(expedition, malware.position, 1)
    if (nearbyProcesses.length > 0) {
      activateMalware(malware)
      logEvent(expedition, 'malware_activated', `${malware.name} awakens!`, {
        actorId: malware.id,
        position: malware.position,
      })
    }
    return { action: 'idle' }
  }

  // Destroyed malware don't act
  if (malware.status === 'destroyed') {
    return { action: 'idle' }
  }

  // Check for flee condition
  const healthPercent = getMalwareHealthPercent(malware)
  if (healthPercent <= malware.behavior.fleeHealthPercent) {
    malware.status = 'fleeing'
    const fleeTarget = findFleePosition(malware, expedition)
    if (fleeTarget) {
      return { action: 'flee', target: fleeTarget }
    }
  }

  // Check for processes in aggro range
  const inAggroRange = getProcessesInRange(expedition, malware.position, malware.behavior.aggroRange)

  if (inAggroRange.length > 0) {
    // Become alerted if not already
    if (malware.status !== 'alerted') {
      malware.status = 'alerted'
    }

    // Check for ability use
    if (canUseAbility(malware) && malware.behavior.specialAbility) {
      const abilityDecision = decideAbilityUse(malware, expedition, inAggroRange)
      if (abilityDecision) {
        return abilityDecision
      }
    }

    // Find target based on preference
    const target = selectTarget(malware, inAggroRange)

    // If adjacent, attack
    const distance = getManhattanDistance(malware.position, target.position)
    if (distance <= 1) {
      return { action: 'attack', targetId: target.id }
    }

    // If mobile, move toward target
    if (malware.stats.speed > 0) {
      return { action: 'move', target: target.position, targetId: target.id }
    }
  } else {
    // No targets in range, become active (not alerted)
    if (malware.status === 'alerted') {
      malware.status = 'active'
    }
  }

  return { action: 'idle' }
}

/**
 * Select a target based on malware's preferred target type
 */
function selectTarget(malware: Malware, candidates: Process[]): Process {
  if (candidates.length === 1) return candidates[0]!

  switch (malware.behavior.preferredTarget) {
    case 'nearest':
      return candidates.reduce((a, b) =>
        getManhattanDistance(malware.position, a.position) <
        getManhattanDistance(malware.position, b.position) ? a : b
      )

    case 'weakest':
      return candidates.reduce((a, b) =>
        a.stats.health < b.stats.health ? a : b
      )

    case 'strongest':
      return candidates.reduce((a, b) =>
        a.stats.health > b.stats.health ? a : b
      )

    case 'random':
      return candidates[Math.floor(Math.random() * candidates.length)]!

    default:
      return candidates[0]!
  }
}

/**
 * Find a position to flee to (away from threats)
 */
function findFleePosition(malware: Malware, expedition: Expedition): GridPosition | null {
  const threats = getAliveProcesses(expedition)
  if (threats.length === 0) return null

  // Calculate average threat position
  let avgX = 0
  let avgY = 0
  for (const threat of threats) {
    avgX += threat.position.x
    avgY += threat.position.y
  }
  avgX = Math.floor(avgX / threats.length)
  avgY = Math.floor(avgY / threats.length)

  // Find direction away from threats
  const dx = malware.position.x - avgX
  const dy = malware.position.y - avgY

  // Try to move in that direction
  const candidates = [
    { x: malware.position.x + Math.sign(dx), y: malware.position.y },
    { x: malware.position.x, y: malware.position.y + Math.sign(dy) },
    { x: malware.position.x + Math.sign(dx), y: malware.position.y + Math.sign(dy) },
  ]

  for (const pos of candidates) {
    const tile = getTile(expedition.sector.grid, pos)
    if (tile && isWalkable(tile) && !getMalwareAt(expedition, pos)) {
      return pos
    }
  }

  return null
}

/**
 * Decide whether to use a special ability
 */
function decideAbilityUse(
  malware: Malware,
  _expedition: Expedition,
  targets: Process[]
): AIDecision | null {
  const ability = malware.behavior.specialAbility
  if (!ability) return null

  switch (ability.effect) {
    case 'replicate':
      // Worms replicate when they have enough targets
      if (targets.length >= 2) {
        return { action: 'ability' }
      }
      break

    case 'explode': {
      // Logic bombs explode when adjacent to a process
      const adjacent = targets.filter(
        t => getManhattanDistance(malware.position, t.position) <= 1
      )
      if (adjacent.length > 0) {
        return { action: 'ability' }
      }
      break
    }

    case 'corrupt_tile':
      // Rootkits corrupt tiles periodically
      return { action: 'ability' }

    case 'stealth':
      // Re-stealth when damaged
      if (getMalwareHealthPercent(malware) < 80) {
        return { action: 'ability' }
      }
      break

    case 'entangle': {
      // Trojans entangle adjacent targets
      const adjacentTargets = targets.filter(
        t => getManhattanDistance(malware.position, t.position) <= 1
      )
      if (adjacentTargets.length > 0) {
        return { action: 'ability', targetId: adjacentTargets[0]!.id }
      }
      break
    }
  }

  return null
}

// ============= AI Execution =============

/**
 * Execute the AI decision for a malware entity
 */
export function executeMalwareAI(
  malware: Malware,
  expedition: Expedition
): void {
  // Tick cooldowns
  tickMalwareCooldown(malware)

  const decision = decideMalwareAction(malware, expedition)

  switch (decision.action) {
    case 'move':
      if (decision.target && malware.stats.speed > 0) {
        moveMalwareToward(malware, decision.target, expedition)
      }
      break

    case 'ability':
      executeAbility(malware, expedition, decision.targetId)
      break

    // Attack is handled by CombatSystem
    // Flee movement is handled like regular movement
    case 'flee':
      if (decision.target && malware.stats.speed > 0) {
        moveMalwareToward(malware, decision.target, expedition)
      }
      break
  }
}

/**
 * Move malware one step toward a target
 */
function moveMalwareToward(
  malware: Malware,
  target: GridPosition,
  expedition: Expedition
): boolean {
  const path = findPath(expedition.sector.grid, malware.position, target)

  if (!path || path.length < 2) return false

  const nextPos = path[1]!
  const tile = getTile(expedition.sector.grid, nextPos)

  if (!tile || !isWalkable(tile)) return false

  // Check for collision with other malware
  if (getMalwareAt(expedition, nextPos)) return false

  malware.position = { ...nextPos }
  return true
}

/**
 * Execute a malware's special ability
 */
function executeAbility(
  malware: Malware,
  expedition: Expedition,
  targetId?: string
): void {
  const ability = malware.behavior.specialAbility
  if (!ability || !canUseAbility(malware)) return

  switch (ability.effect) {
    case 'replicate':
      replicateMalware(malware, expedition)
      break

    case 'explode':
      explodeMalware(malware, expedition, ability.value)
      break

    case 'corrupt_tile':
      corruptNearbyTile(malware, expedition, ability.value)
      break

    case 'entangle':
      if (targetId) {
        entangleTarget(malware, expedition, targetId, ability.value)
      }
      break

    case 'stealth':
      malware.isRevealed = false
      logEvent(expedition, 'malware_ability_used', `${malware.name} vanishes!`, {
        actorId: malware.id,
        position: malware.position,
      })
      break
  }

  useAbility(malware)
}

function replicateMalware(malware: Malware, expedition: Expedition): void {
  // Find empty adjacent tile
  const offsets = [
    { x: -1, y: 0 }, { x: 1, y: 0 },
    { x: 0, y: -1 }, { x: 0, y: 1 },
  ]

  for (const offset of offsets) {
    const pos = {
      x: malware.position.x + offset.x,
      y: malware.position.y + offset.y,
    }

    const tile = getTile(expedition.sector.grid, pos)
    if (!tile || !isWalkable(tile)) continue
    if (getMalwareAt(expedition, pos)) continue

    // TODO: Create new malware at this position
    // For now just log the attempt
    logEvent(expedition, 'malware_ability_used', `${malware.name} attempts to replicate`, {
      actorId: malware.id,
      position: pos,
    })

    return
  }

  // No valid position found
  logEvent(expedition, 'malware_ability_used', `${malware.name} failed to replicate`, {
    actorId: malware.id,
    position: malware.position,
  })
}

function explodeMalware(
  malware: Malware,
  expedition: Expedition,
  radius: number
): void {
  logEvent(expedition, 'malware_ability_used', `${malware.name} EXPLODES!`, {
    actorId: malware.id,
    position: malware.position,
  })

  areaAttack(
    { id: malware.id, type: 'malware', attack: malware.stats.attack },
    malware.position,
    radius,
    expedition
  )

  // Logic bomb destroys itself
  malware.status = 'destroyed'
  malware.stats.health = 0

  logEvent(expedition, 'malware_destroyed', `${malware.name} self-destructed`, {
    actorId: malware.id,
    position: malware.position,
  })
}

function corruptNearbyTile(
  malware: Malware,
  expedition: Expedition,
  amount: number
): void {
  const offsets = [
    { x: -1, y: 0 }, { x: 1, y: 0 },
    { x: 0, y: -1 }, { x: 0, y: 1 },
  ]

  // Pick random adjacent tile
  const offset = offsets[Math.floor(Math.random() * offsets.length)]!
  const pos = {
    x: malware.position.x + offset.x,
    y: malware.position.y + offset.y,
  }

  const tile = getTile(expedition.sector.grid, pos)
  if (!tile || tile.type === 'blocked') return

  tile.corruptionLevel = Math.min(100, tile.corruptionLevel + amount)

  logEvent(expedition, 'corruption_spread', `${malware.name} corrupts nearby tile`, {
    actorId: malware.id,
    position: pos,
    value: amount,
  })
}

function entangleTarget(
  malware: Malware,
  expedition: Expedition,
  targetId: string,
  duration: number
): void {
  const target = expedition.processes.get(targetId)
  if (!target) return

  target.statusEffects.push({
    id: `entangle-${malware.id}`,
    name: 'Entangled',
    type: 'debuff',
    duration,
    statModifiers: {
      speed: -target.stats.speed, // Can't move
    },
  })

  logEvent(expedition, 'malware_ability_used', `${malware.name} entangles ${target.name}!`, {
    actorId: malware.id,
    targetId: target.id,
    position: target.position,
  })
}

// ============= Batch AI Processing =============

/**
 * Process AI for all malware in an expedition
 */
export function processAllMalwareAI(expedition: Expedition): void {
  for (const malware of expedition.malware.values()) {
    if (malware.status !== 'destroyed') {
      executeMalwareAI(malware, expedition)
    }
  }
}
