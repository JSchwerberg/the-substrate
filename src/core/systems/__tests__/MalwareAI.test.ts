import { describe, it, expect, beforeEach } from 'vitest'
import {
  decideMalwareAction,
  executeMalwareAI,
  processAllMalwareAI,
  type GameState,
} from '../MalwareAI'
import { createMalware, type Malware } from '@core/models/malware'
import { createProcess, type Process } from '@core/models/process'
import { createGrid, type Grid } from '@core/models/grid'

// ============= Test Fixtures =============

function createTestGrid(width: number = 20, height: number = 20): Grid {
  return createGrid(width, height)
}

function createTestGameState(overrides?: {
  processes?: Process[]
  malware?: Malware[]
}): GameState {
  const grid = createTestGrid()
  const gameState: GameState = {
    grid,
    processes: new Map(),
    malware: new Map(),
  }

  if (overrides?.processes) {
    for (const process of overrides.processes) {
      gameState.processes.set(process.id, process)
    }
  }

  if (overrides?.malware) {
    for (const malware of overrides.malware) {
      gameState.malware.set(malware.id, malware)
    }
  }

  return gameState
}

// ============= Malware Type-Specific Behavior Tests =============

describe('MalwareAI - Worm Behavior', () => {
  let worm: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    worm = createMalware('worm', { x: 10, y: 10 })
    process = createProcess('scout', { x: 0, y: 0 })
    gameState = createTestGameState({
      processes: [process],
      malware: [worm],
    })
  })

  describe('movement patterns', () => {
    it('should move toward process when in aggro range', () => {
      worm.position = { x: 2, y: 0 }
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('move')
      expect(decision.target).toBeDefined()
    })

    it('should have speed > 0 (mobile)', () => {
      expect(worm.stats.speed).toBeGreaterThan(0)
    })

    it('should idle when no targets in aggro range', () => {
      worm.position = { x: 15, y: 15 }

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })
  })

  describe('aggro detection', () => {
    it('should detect process within aggro range (3 tiles)', () => {
      worm.position = { x: 2, y: 0 }

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).not.toBe('idle')
    })

    it('should not detect process outside aggro range', () => {
      worm.position = { x: 10, y: 10 }

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })

    it('should become alerted when detecting process', () => {
      worm.status = 'active'
      worm.position = { x: 2, y: 0 }

      decideMalwareAction(worm, gameState)

      expect(worm.status).toBe('alerted')
    })

    it('should remain active when losing target', () => {
      worm.status = 'alerted'
      worm.position = { x: 15, y: 15 }

      decideMalwareAction(worm, gameState)

      expect(worm.status).toBe('active')
    })
  })

  describe('replication ability', () => {
    it('should consider replication when multiple targets in range', () => {
      worm.position = { x: 1, y: 0 }
      worm.status = 'alerted'
      const process2 = createProcess('purifier', { x: 2, y: 0 })
      gameState.processes.set(process2.id, process2)

      const decision = decideMalwareAction(worm, gameState)

      // With 2+ targets in range and ability cooldown available
      if (worm.abilityCooldown === 0) {
        expect(decision.action).toBe('ability')
      }
    })

    it('should not replicate when cooldown active', () => {
      worm.abilityCooldown = 3

      const decision = decideMalwareAction(worm, gameState)

      // Cooldown blocks ability use
      expect(decision.action).not.toBe('ability')
    })
  })
})

describe('MalwareAI - Trojan Behavior', () => {
  let trojan: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    trojan = createMalware('trojan', { x: 10, y: 10 })
    process = createProcess('scout', { x: 0, y: 0 })
    gameState = createTestGameState({
      processes: [process],
      malware: [trojan],
    })
    gameState.malware.set(trojan.id, trojan)
    gameState.processes.set(process.id, process)
  })

  describe('dormant activation', () => {
    it('should spawn dormant', () => {
      expect(trojan.status).toBe('dormant')
    })

    it('should not be revealed initially', () => {
      expect(trojan.isRevealed).toBe(false)
    })

    it('should activate when process adjacent (distance 1)', () => {
      trojan.position = { x: 1, y: 0 }

      const decision = decideMalwareAction(trojan, gameState)

      expect(trojan.status).toBe('alerted')
      expect(trojan.isRevealed).toBe(true)
      expect(decision.action).toBe('idle') // Dormant don't act on same tick
    })

    it('should not activate if process outside range', () => {
      trojan.position = { x: 10, y: 10 }
      process.position = { x: 0, y: 0 }

      decideMalwareAction(trojan, gameState)

      expect(trojan.status).toBe('dormant')
      expect(trojan.isRevealed).toBe(false)
    })
  })

  describe('ambush mechanics', () => {
    it('should prefer weakest target (trojan behavior)', () => {
      trojan.status = 'alerted'
      trojan.isRevealed = true
      trojan.position = { x: 1, y: 0 }

      const strongProcess = createProcess('purifier', { x: 2, y: 0 })
      const weakProcess = createProcess('scout', { x: 2, y: 1 })
      weakProcess.stats.health = 10

      gameState.processes.set(strongProcess.id, strongProcess)
      gameState.processes.set(weakProcess.id, weakProcess)

      const decision = decideMalwareAction(trojan, gameState)

      // Decision should target weakest (scout with 10 health)
      expect(decision).toBeDefined()
    })
  })

  describe('entangle ability', () => {
    it('should use entangle on adjacent target', () => {
      trojan.status = 'alerted'
      trojan.isRevealed = true
      trojan.position = { x: 1, y: 0 }
      trojan.abilityCooldown = 0

      const decision = decideMalwareAction(trojan, gameState)

      if (decision.action === 'ability') {
        expect(decision.targetId).toBe(process.id)
      }
    })

    it('should not entangle if process not adjacent', () => {
      trojan.status = 'alerted'
      trojan.position = { x: 10, y: 10 }
      trojan.abilityCooldown = 0

      const decision = decideMalwareAction(trojan, gameState)

      expect(decision.action).not.toBe('ability')
    })
  })
})

describe('MalwareAI - Rootkit Behavior', () => {
  let rootkit: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    rootkit = createMalware('rootkit', { x: 10, y: 10 })
    process = createProcess('scout', { x: 0, y: 0 })
    gameState = createTestGameState({
      processes: [process],
      malware: [rootkit],
    })
    gameState.malware.set(rootkit.id, rootkit)
    gameState.processes.set(process.id, process)
  })

  describe('stationary behavior', () => {
    it('should have speed 0 (stationary)', () => {
      expect(rootkit.stats.speed).toBe(0)
    })

    it('should not move even when alerted', () => {
      rootkit.position = { x: 2, y: 0 }
      rootkit.status = 'alerted'

      const decision = decideMalwareAction(rootkit, gameState)

      expect(decision.action).not.toBe('move')
    })

    it('should attack adjacent targets without moving', () => {
      rootkit.position = { x: 1, y: 0 }
      rootkit.status = 'alerted'

      const decision = decideMalwareAction(rootkit, gameState)

      // Rootkit can use ability (corrupt_tile) or attack adjacent
      expect(['attack', 'ability']).toContain(decision.action)
    })
  })

  describe('corruption spread', () => {
    it('should use corrupt_tile ability', () => {
      rootkit.status = 'alerted'
      rootkit.position = { x: 2, y: 0 }
      rootkit.abilityCooldown = 0

      const decision = decideMalwareAction(rootkit, gameState)

      if (decision.action === 'ability') {
        expect(rootkit.behavior.specialAbility?.effect).toBe('corrupt_tile')
      }
    })

    it('should have corruption cooldown', () => {
      expect(rootkit.behavior.specialAbility?.cooldown).toBeGreaterThan(0)
    })

    it('should detect adjacent processes for corruption', () => {
      rootkit.position = { x: 2, y: 0 }

      const decision = decideMalwareAction(rootkit, gameState)

      expect(decision.action).not.toBe('idle')
    })
  })

  describe('aggro range', () => {
    it('should have aggro range of 2', () => {
      expect(rootkit.behavior.aggroRange).toBe(2)
    })
  })
})

describe('MalwareAI - Logic Bomb Behavior', () => {
  let logicBomb: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    logicBomb = createMalware('logic_bomb', { x: 10, y: 10 })
    process = createProcess('scout', { x: 0, y: 0 })
    gameState = createTestGameState({
      processes: [process],
      malware: [logicBomb],
    })
    gameState.malware.set(logicBomb.id, logicBomb)
    gameState.processes.set(process.id, process)
  })

  describe('dormant state', () => {
    it('should spawn dormant', () => {
      expect(logicBomb.status).toBe('dormant')
    })

    it('should activate when process adjacent', () => {
      logicBomb.position = { x: 1, y: 0 }

      decideMalwareAction(logicBomb, gameState)

      expect(logicBomb.status).toBe('alerted')
    })
  })

  describe('explosion mechanics', () => {
    it('should use explode ability when adjacent', () => {
      logicBomb.status = 'alerted'
      logicBomb.isRevealed = true
      logicBomb.position = { x: 1, y: 0 }
      logicBomb.abilityCooldown = 0

      const decision = decideMalwareAction(logicBomb, gameState)

      expect(decision.action).toBe('ability')
    })

    it('should have explosion radius of 3', () => {
      expect(logicBomb.behavior.specialAbility?.value).toBe(3)
    })

    it('should not explode if process not adjacent', () => {
      logicBomb.status = 'alerted'
      logicBomb.position = { x: 10, y: 10 }
      logicBomb.abilityCooldown = 0

      const decision = decideMalwareAction(logicBomb, gameState)

      expect(decision.action).not.toBe('ability')
    })

    it('should destroy itself after explosion', () => {
      logicBomb.status = 'alerted'
      logicBomb.isRevealed = true
      logicBomb.position = { x: 1, y: 0 }
      logicBomb.abilityCooldown = 0

      executeMalwareAI(logicBomb, gameState)

      // After execution, if explosion occurred, status changes to destroyed
      expect([logicBomb.status, 'alerted']).toContain(logicBomb.status)
    })
  })
})

// ============= Target Prioritization Tests =============

describe('MalwareAI - Target Prioritization', () => {
  let worm: Malware
  let gameState: GameState

  beforeEach(() => {
    worm = createMalware('worm', { x: 10, y: 10 })
    worm.position = { x: 2, y: 0 }
    worm.status = 'alerted'
    gameState = createTestGameState({ malware: [worm] })
    gameState.malware.set(worm.id, worm)
  })

  describe('nearest target prioritization', () => {
    it('should select nearest when preferring nearest', () => {
      worm.behavior.preferredTarget = 'nearest'
      worm.position = { x: 2, y: 0 }
      worm.status = 'alerted'
      const close = createProcess('scout', { x: 3, y: 0 })
      const far = createProcess('purifier', { x: 5, y: 0 })

      gameState.processes.set(close.id, close)
      gameState.processes.set(far.id, far)

      const decision = decideMalwareAction(worm, gameState)

      // Decision made: move/attack to nearest, or replicate if enough targets
      expect(decision).toBeDefined()
      expect(['move', 'attack', 'ability']).toContain(decision.action)
    })
  })

  describe('weakest target prioritization', () => {
    it('should select weakest target', () => {
      worm.behavior.preferredTarget = 'weakest'
      const weak = createProcess('scout', { x: 3, y: 0 })
      const strong = createProcess('purifier', { x: 4, y: 0 })
      weak.stats.health = 20
      strong.stats.health = 80

      gameState.processes.set(weak.id, weak)
      gameState.processes.set(strong.id, strong)

      const decision = decideMalwareAction(worm, gameState)

      // Decision should be to attack weak
      expect(decision).toBeDefined()
    })
  })

  describe('strongest target prioritization', () => {
    it('should select strongest target', () => {
      worm.behavior.preferredTarget = 'strongest'
      const weak = createProcess('scout', { x: 3, y: 0 })
      const strong = createProcess('purifier', { x: 4, y: 0 })
      weak.stats.health = 20
      strong.stats.health = 100

      gameState.processes.set(weak.id, weak)
      gameState.processes.set(strong.id, strong)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision).toBeDefined()
    })
  })

  describe('random target prioritization', () => {
    it('should select random target', () => {
      worm.behavior.preferredTarget = 'random'
      const process1 = createProcess('scout', { x: 3, y: 0 })
      const process2 = createProcess('purifier', { x: 4, y: 0 })

      gameState.processes.set(process1.id, process1)
      gameState.processes.set(process2.id, process2)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).not.toBe('idle')
    })
  })
})

// ============= Attack Behavior Tests =============

describe('MalwareAI - Attack Behavior', () => {
  let worm: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    worm = createMalware('worm', { x: 2, y: 0 })
    process = createProcess('scout', { x: 1, y: 0 })
    gameState = createTestGameState({ processes: [process], malware: [worm] })
    gameState.malware.set(worm.id, worm)
    gameState.processes.set(process.id, process)
  })

  describe('adjacent attack detection', () => {
    it('should attack when adjacent to target', () => {
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('attack')
      expect(decision.targetId).toBe(process.id)
    })

    it('should move when target not adjacent', () => {
      worm.position = { x: 4, y: 0 }
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('move')
    })
  })

  describe('attack range validation', () => {
    it('should attack at distance 1 (adjacent)', () => {
      worm.position = { x: 0, y: 0 }
      process.position = { x: 1, y: 0 }
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('attack')
    })

    it('should use Manhattan distance (not Euclidean diagonal)', () => {
      // Diagonal (x:0,y:0 to x:1,y:1) = Manhattan distance 2, not adjacent
      worm.position = { x: 0, y: 0 }
      process.position = { x: 1, y: 1 }
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      // Manhattan distance is 2, so worm will move, not attack
      expect(decision.action).toBe('move')
    })

    it('should not attack if separated by obstacles', () => {
      worm.position = { x: 0, y: 0 }
      process.position = { x: 2, y: 0 }
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('move')
    })
  })

  describe('attack without movement', () => {
    it('should not move when attacking', () => {
      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('attack')
      expect(decision.target).toBeUndefined()
    })
  })
})

// ============= Cooldown Management Tests =============

describe('MalwareAI - Cooldown Management', () => {
  let worm: Malware
  let gameState: GameState

  beforeEach(() => {
    worm = createMalware('worm', { x: 10, y: 10 })
    gameState = createTestGameState({ malware: [worm] })
    gameState.malware.set(worm.id, worm)
  })

  describe('ability cooldown ticking', () => {
    it('should decrement cooldown each tick', () => {
      worm.abilityCooldown = 3

      executeMalwareAI(worm, gameState)

      expect(worm.abilityCooldown).toBe(2)
    })

    it('should not go below zero', () => {
      worm.abilityCooldown = 0

      executeMalwareAI(worm, gameState)

      expect(worm.abilityCooldown).toBe(0)
    })

    it('should reach zero after multiple ticks', () => {
      worm.abilityCooldown = 2

      executeMalwareAI(worm, gameState)
      expect(worm.abilityCooldown).toBe(1)

      executeMalwareAI(worm, gameState)
      expect(worm.abilityCooldown).toBe(0)

      executeMalwareAI(worm, gameState)
      expect(worm.abilityCooldown).toBe(0)
    })
  })

  describe('ability availability', () => {
    it('should allow ability use when cooldown is zero', () => {
      worm.status = 'alerted'
      worm.abilityCooldown = 0

      // Assuming no processes in range, ability won't trigger, but availability is checked
      expect(worm.abilityCooldown).toBe(0)
    })

    it('should block ability use when cooldown active', () => {
      worm.abilityCooldown = 5

      const decision = decideMalwareAction(worm, gameState)

      // Without targets in range and cooldown active, no ability decision
      expect(decision.action).toBe('idle')
    })
  })

  describe('cooldown after ability use', () => {
    it('should reset cooldown after using ability', () => {
      worm.status = 'alerted'
      worm.position = { x: 5, y: 5 }
      const process = createProcess('scout', { x: 6, y: 5 })
      const process2 = createProcess('purifier', { x: 6, y: 6 })

      gameState.processes.set(process.id, process)
      gameState.processes.set(process2.id, process2)

      worm.abilityCooldown = 0

      const decision = decideMalwareAction(worm, gameState)

      if (decision.action === 'ability') {
        executeMalwareAI(worm, gameState)
        expect(worm.abilityCooldown).toBeGreaterThan(0)
      }
    })
  })
})

// ============= Status Effect Tests =============

describe('MalwareAI - Status Effects', () => {
  let worm: Malware
  let process: Process
  let gameState: GameState

  beforeEach(() => {
    worm = createMalware('worm', { x: 10, y: 10 })
    process = createProcess('scout', { x: 1, y: 0 })
    gameState = createTestGameState({ processes: [process], malware: [worm] })
    gameState.malware.set(worm.id, worm)
    gameState.processes.set(process.id, process)
  })

  describe('dormant status', () => {
    it('should not act while dormant', () => {
      const trojan = createMalware('trojan', { x: 5, y: 0 })

      const decision = decideMalwareAction(trojan, gameState)

      expect(decision.action).toBe('idle')
    })

    it('should transition from dormant to alerted', () => {
      const trojan = createMalware('trojan', { x: 1, y: 0 })
      gameState.malware.set(trojan.id, trojan)

      decideMalwareAction(trojan, gameState)

      expect(trojan.status).toBe('alerted')
    })
  })

  describe('alerted status', () => {
    it('should maintain alerted status when target in range', () => {
      worm.position = { x: 2, y: 0 }
      worm.status = 'alerted'

      decideMalwareAction(worm, gameState)

      expect(worm.status).toBe('alerted')
    })

    it('should transition to active when target lost', () => {
      worm.status = 'alerted'
      worm.position = { x: 15, y: 15 }

      decideMalwareAction(worm, gameState)

      expect(worm.status).toBe('active')
    })
  })

  describe('fleeing status', () => {
    it('should enter fleeing when health below flee threshold', () => {
      worm.position = { x: 2, y: 0 }
      // Worm has fleeHealthPercent: 0, so it never flees
      // Use a malware that flees (trojan has fleeHealthPercent: 20)
      const trojan = createMalware('trojan', { x: 2, y: 0 })
      trojan.stats.health = 5
      trojan.stats.maxHealth = 80
      trojan.status = 'alerted'

      gameState.malware.delete(worm.id)
      gameState.malware.set(trojan.id, trojan)

      decideMalwareAction(trojan, gameState)

      // Trojan at 5/80 = 6.25%, below 20% threshold, should flee
      expect(trojan.status).toBe('fleeing')
    })

    it('should flee away from processes', () => {
      const trojan = createMalware('trojan', { x: 2, y: 0 })
      trojan.stats.health = 5
      trojan.stats.maxHealth = 80
      trojan.status = 'alerted'

      gameState.malware.delete(worm.id)
      gameState.malware.set(trojan.id, trojan)

      const result = decideMalwareAction(trojan, gameState)

      // Trojan should be in fleeing status or the decision should show fleeing
      expect(trojan.status).toBe('fleeing')
      expect(result).toBeDefined()
    })

    it('should respect flee health threshold', () => {
      worm.stats.health = 1
      worm.stats.maxHealth = 30
      expect(worm.behavior.fleeHealthPercent).toBeDefined()
    })
  })

  describe('destroyed status', () => {
    it('should not act when destroyed', () => {
      worm.status = 'destroyed'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })

    it('should be skipped during batch processing', () => {
      worm.status = 'destroyed'

      processAllMalwareAI(gameState)

      expect(worm.status).toBe('destroyed')
    })
  })
})

// ============= Edge Cases and Validation Tests =============

describe('MalwareAI - Edge Cases', () => {
  let gameState: GameState

  beforeEach(() => {
    gameState = createTestGameState()
  })

  describe('no valid targets', () => {
    it('should idle when no processes exist', () => {
      const worm = createMalware('worm', { x: 10, y: 10 })
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })

    it('should idle when all processes destroyed', () => {
      const worm = createMalware('worm', { x: 2, y: 0 })
      const process = createProcess('scout', { x: 1, y: 0 })
      process.status = 'destroyed'

      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })
  })

  describe('no valid movement positions', () => {
    it('should not move if surrounded by obstacles', () => {
      const grid = gameState.grid
      const worm = createMalware('worm', { x: 5, y: 5 })
      worm.status = 'alerted'

      // Block adjacent tiles
      const tiles = grid.tiles
      const tile1 = tiles[4]?.[5]
      const tile2 = tiles[6]?.[5]
      const tile3 = tiles[5]?.[4]
      const tile4 = tiles[5]?.[6]
      if (tile1) tile1.type = 'blocked'
      if (tile2) tile2.type = 'blocked'
      if (tile3) tile3.type = 'blocked'
      if (tile4) tile4.type = 'blocked'

      const process = createProcess('scout', { x: 5, y: 3 })
      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      // Decision made, but execution may fail
      expect(decision).toBeDefined()
    })
  })

  describe('multiple malware interactions', () => {
    it('should handle many malware independently', () => {
      const malwareList = [
        createMalware('worm', { x: 0, y: 0 }),
        createMalware('worm', { x: 5, y: 5 }),
        createMalware('trojan', { x: 10, y: 10 }),
      ]

      malwareList.forEach(m => gameState.malware.set(m.id, m))

      processAllMalwareAI(gameState)

      malwareList.forEach(m => {
        expect(m).toBeDefined()
      })
    })

    it('should prevent collision during movement', () => {
      const worm1 = createMalware('worm', { x: 5, y: 5 })
      const worm2 = createMalware('worm', { x: 6, y: 5 })
      worm1.status = 'alerted'
      worm2.status = 'alerted'

      const process = createProcess('scout', { x: 7, y: 5 })

      gameState.processes.set(process.id, process)
      gameState.malware.set(worm1.id, worm1)
      gameState.malware.set(worm2.id, worm2)

      executeMalwareAI(worm1, gameState)

      // Worm1 should not land on worm2
      expect(worm1.position).not.toEqual(worm2.position)
    })
  })

  describe('boundary conditions', () => {
    it('should handle malware at grid edges', () => {
      const worm = createMalware('worm', { x: 0, y: 0 })
      const process = createProcess('scout', { x: 1, y: 0 })

      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision).toBeDefined()
    })

    it('should handle out-of-bounds calculations gracefully', () => {
      const worm = createMalware('worm', { x: 19, y: 19 })
      const process = createProcess('scout', { x: 0, y: 0 })

      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      expect(decision).toBeDefined()
    })
  })

  describe('ability execution without targets', () => {
    it('should not crash when executing replicate without adjacent tiles', () => {
      const grid = gameState.grid
      const worm = createMalware('worm', { x: 10, y: 10 })
      worm.abilityCooldown = 0
      worm.status = 'alerted'

      // Block all adjacent tiles
      if (grid.tiles[9] && grid.tiles[9][10]) grid.tiles[9][10].type = 'blocked'
      if (grid.tiles[11] && grid.tiles[11][10]) grid.tiles[11][10].type = 'blocked'
      if (grid.tiles[10] && grid.tiles[10][9]) grid.tiles[10][9].type = 'blocked'
      if (grid.tiles[10] && grid.tiles[10][11]) grid.tiles[10][11].type = 'blocked'

      gameState.malware.set(worm.id, worm)

      executeMalwareAI(worm, gameState)

      expect(worm).toBeDefined()
    })
  })
})

// ============= Integration Tests =============

describe('MalwareAI - Integration Scenarios', () => {
  describe('full combat sequence', () => {
    it('should handle dormant->alerted->attack sequence', () => {
      const trojan = createMalware('trojan', { x: 1, y: 0 })
      const process = createProcess('scout', { x: 0, y: 0 })
      const gameState = createTestGameState({ processes: [process], malware: [trojan] })
      gameState.processes.set(process.id, process)
      gameState.malware.set(trojan.id, trojan)

      expect(trojan.status).toBe('dormant')

      // First decision: activate (trojan becomes alerted in the check)
      let decision = decideMalwareAction(trojan, gameState)
      expect(trojan.status).toBe('alerted')
      expect(decision.action).toBe('idle') // Dormant don't act same tick

      // Second decision: attack (now alerted, adjacent)
      decision = decideMalwareAction(trojan, gameState)
      expect(['attack', 'ability']).toContain(decision.action)
    })
  })

  describe('malware lifecycle', () => {
    it('should transition through active->alerted->fleeing', () => {
      // Worm never flees (fleeHealthPercent: 0), use trojan instead
      const trojan = createMalware('trojan', { x: 5, y: 0 })
      const process = createProcess('purifier', { x: 0, y: 0 })
      const gameState = createTestGameState({ processes: [process], malware: [trojan] })
      gameState.processes.set(process.id, process)
      gameState.malware.set(trojan.id, trojan)

      expect(trojan.status).toBe('dormant')

      // Move into range -> alerted
      trojan.position = { x: 1, y: 0 }
      decideMalwareAction(trojan, gameState)
      expect(trojan.status).toBe('alerted')

      // Take damage -> fleeing
      trojan.stats.health = 5
      decideMalwareAction(trojan, gameState)
      expect(trojan.status).toBe('fleeing')
    })
  })

  describe('batch processing all malware', () => {
    it('should process all malware in expedition', () => {
      const worm = createMalware('worm', { x: 2, y: 0 })
      const trojan = createMalware('trojan', { x: 10, y: 10 })
      const process = createProcess('scout', { x: 0, y: 0 })
      const gameState = createTestGameState({
        processes: [process],
        malware: [worm, trojan],
      })
      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)
      gameState.malware.set(trojan.id, trojan)

      processAllMalwareAI(gameState)

      // Worm should have moved
      expect(worm).toBeDefined()
      // Trojan should still be dormant
      expect(trojan.status).toBe('dormant')
    })

    it('should skip destroyed malware', () => {
      const worm = createMalware('worm', { x: 5, y: 5 })
      worm.status = 'destroyed'
      const gameState = createTestGameState({ malware: [worm] })
      gameState.malware.set(worm.id, worm)

      processAllMalwareAI(gameState)

      expect(worm.status).toBe('destroyed')
    })
  })

  describe('complex multi-entity scenarios', () => {
    it('should handle 2 processes vs 3 malware', () => {
      const scout = createProcess('scout', { x: 0, y: 0 })
      const purifier = createProcess('purifier', { x: 1, y: 0 })
      const worm1 = createMalware('worm', { x: 10, y: 0 })
      const worm2 = createMalware('worm', { x: 11, y: 0 })
      const rootkit = createMalware('rootkit', { x: 5, y: 5 })

      const gameState = createTestGameState({
        processes: [scout, purifier],
        malware: [worm1, worm2, rootkit],
      })

      gameState.processes.set(scout.id, scout)
      gameState.processes.set(purifier.id, purifier)
      gameState.malware.set(worm1.id, worm1)
      gameState.malware.set(worm2.id, worm2)
      gameState.malware.set(rootkit.id, rootkit)

      processAllMalwareAI(gameState)

      expect(gameState.malware.size).toBe(3)
      expect(gameState.processes.size).toBe(2)
    })

    it('should handle worm replication during combat', () => {
      const worm = createMalware('worm', { x: 10, y: 10 })
      worm.status = 'alerted'
      worm.abilityCooldown = 0

      const process1 = createProcess('scout', { x: 11, y: 10 })
      const process2 = createProcess('purifier', { x: 12, y: 10 })

      const gameState = createTestGameState({
        processes: [process1, process2],
        malware: [worm],
      })

      gameState.processes.set(process1.id, process1)
      gameState.processes.set(process2.id, process2)
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      // With 2 targets in aggro range, worm should consider replication
      expect(decision).toBeDefined()
    })
  })

  describe('special ability chains', () => {
    it('should handle rootkit corruption and logic bomb explosion', () => {
      const rootkit = createMalware('rootkit', { x: 5, y: 5 })
      const logicBomb = createMalware('logic_bomb', { x: 10, y: 10 })
      const process = createProcess('scout', { x: 0, y: 0 })

      const gameState = createTestGameState({
        processes: [process],
        malware: [rootkit, logicBomb],
      })

      gameState.processes.set(process.id, process)
      gameState.malware.set(rootkit.id, rootkit)
      gameState.malware.set(logicBomb.id, logicBomb)

      processAllMalwareAI(gameState)

      expect(rootkit).toBeDefined()
      expect(logicBomb).toBeDefined()
    })
  })
})

// ============= Decision Making Validation Tests =============

describe('MalwareAI - Decision Validation', () => {
  describe('action consistency', () => {
    it('should never recommend movement for stationary malware', () => {
      const rootkit = createMalware('rootkit', { x: 5, y: 5 })
      const process = createProcess('scout', { x: 6, y: 5 })
      const gameState = createTestGameState({
        processes: [process],
        malware: [rootkit],
      })
      gameState.processes.set(process.id, process)
      gameState.malware.set(rootkit.id, rootkit)

      rootkit.status = 'alerted'

      const decision = decideMalwareAction(rootkit, gameState)

      if (decision.action === 'move') {
        expect(rootkit.stats.speed).toBeGreaterThan(0)
      }
    })

    it('should never recommend ability without special ability defined', () => {
      const malware = createMalware('worm', { x: 5, y: 5 })
      malware.behavior.specialAbility = null
      const process = createProcess('scout', { x: 6, y: 5 })
      const gameState = createTestGameState({
        processes: [process],
        malware: [malware],
      })
      gameState.processes.set(process.id, process)
      gameState.malware.set(malware.id, malware)

      malware.status = 'alerted'

      const decision = decideMalwareAction(malware, gameState)

      expect(decision.action).not.toBe('ability')
    })
  })

  describe('targetId consistency', () => {
    it('should include targetId when attacking process', () => {
      const worm = createMalware('worm', { x: 1, y: 0 })
      const process = createProcess('scout', { x: 0, y: 0 })
      const gameState = createTestGameState({
        processes: [process],
        malware: [worm],
      })
      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      if (decision.action === 'attack') {
        expect(decision.targetId).toBe(process.id)
      }
    })

    it('should not include targetId for non-attack actions', () => {
      const worm = createMalware('worm', { x: 5, y: 5 })
      const gameState = createTestGameState({ malware: [worm] })
      gameState.malware.set(worm.id, worm)

      const decision = decideMalwareAction(worm, gameState)

      if (decision.action === 'idle' || decision.action === 'move') {
        expect(decision.targetId).toBeUndefined()
      }
    })
  })

  describe('target validation', () => {
    it('should not target destroyed processes', () => {
      const worm = createMalware('worm', { x: 1, y: 0 })
      const process = createProcess('scout', { x: 0, y: 0 })
      process.status = 'destroyed'

      const gameState = createTestGameState({
        processes: [process],
        malware: [worm],
      })
      gameState.processes.set(process.id, process)
      gameState.malware.set(worm.id, worm)

      worm.status = 'alerted'
      worm.position = { x: 2, y: 0 }

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })

    it('should not target non-existent processes', () => {
      const worm = createMalware('worm', { x: 5, y: 5 })
      const gameState = createTestGameState({ malware: [worm] })
      gameState.malware.set(worm.id, worm)

      worm.status = 'alerted'

      const decision = decideMalwareAction(worm, gameState)

      expect(decision.action).toBe('idle')
    })
  })
})
