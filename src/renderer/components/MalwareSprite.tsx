import { useCallback } from 'react'
import { Graphics } from 'pixi.js'
import { Malware, getMalwareHealthPercent } from '@core/models/malware'

interface MalwareSpriteProps {
  malware: Malware
  tileSize: number
  isVisible: boolean // Based on fog of war
}

export function MalwareSprite({ malware, tileSize, isVisible }: MalwareSpriteProps) {
  const draw = useCallback(
    (g: Graphics) => {
      g.clear()

      // Don't draw unrevealed malware (trojans)
      if (!malware.isRevealed || !isVisible) {
        return
      }

      const cx = malware.position.x * tileSize + tileSize / 2
      const cy = malware.position.y * tileSize + tileSize / 2
      const size = tileSize * 0.35

      // Draw shape based on malware type
      switch (malware.shape) {
        case 'square':
          // Worm: rotated square
          g.moveTo(cx, cy - size)
          g.lineTo(cx + size, cy)
          g.lineTo(cx, cy + size)
          g.lineTo(cx - size, cy)
          g.closePath()
          g.fill(malware.color)
          break

        case 'triangle':
          // Trojan: triangle
          g.moveTo(cx, cy - size)
          g.lineTo(cx + size, cy + size * 0.7)
          g.lineTo(cx - size, cy + size * 0.7)
          g.closePath()
          g.fill(malware.color)
          break

        case 'diamond':
          // Logic bomb: diamond with inner glow
          g.moveTo(cx, cy - size * 1.2)
          g.lineTo(cx + size, cy)
          g.lineTo(cx, cy + size * 1.2)
          g.lineTo(cx - size, cy)
          g.closePath()
          g.fill(malware.color)

          // Inner warning symbol
          g.setStrokeStyle({ width: 2, color: 0xffffff })
          g.moveTo(cx, cy - size * 0.5)
          g.lineTo(cx, cy + size * 0.2)
          g.stroke()
          g.circle(cx, cy + size * 0.5, 2)
          g.fill(0xffffff)
          break

        case 'hexagon': {
          // Rootkit: hexagon
          const angle = Math.PI / 3
          g.moveTo(cx + size * Math.cos(0), cy + size * Math.sin(0))
          for (let i = 1; i <= 6; i++) {
            g.lineTo(cx + size * Math.cos(angle * i), cy + size * Math.sin(angle * i))
          }
          g.closePath()
          g.fill(malware.color)
          break
        }
      }

      // Draw outline
      g.setStrokeStyle({ width: 1, color: 0x000000, alpha: 0.5 })

      // Status indicator
      if (malware.status === 'alerted') {
        // Alert: exclamation mark above
        g.setStrokeStyle({ width: 2, color: 0xffffff })
        g.moveTo(cx, cy - size - 10)
        g.lineTo(cx, cy - size - 4)
        g.stroke()
        g.circle(cx, cy - size - 2, 1.5)
        g.fill(0xffffff)
      }

      // Draw health bar if damaged
      const healthPercent = getMalwareHealthPercent(malware)
      if (healthPercent < 100) {
        const barWidth = tileSize * 0.7
        const barHeight = 3
        const barX = cx - barWidth / 2
        const barY = cy + size + 6

        // Background
        g.rect(barX, barY, barWidth, barHeight)
        g.fill({ color: 0x000000, alpha: 0.7 })

        // Health fill
        const healthWidth = (barWidth * healthPercent) / 100
        g.rect(barX, barY, healthWidth, barHeight)
        g.fill(0xef4444)

        // Border
        g.setStrokeStyle({ width: 1, color: 0xffffff, alpha: 0.3 })
        g.rect(barX, barY, barWidth, barHeight)
        g.stroke()
      }
    },
    [malware, tileSize, isVisible]
  )

  // Don't render destroyed malware
  if (malware.status === 'destroyed') {
    return null
  }

  return <pixiGraphics draw={draw} />
}

// Multiple malware renderer
interface MalwareLayerProps {
  malware: Malware[]
  tileSize: number
  visiblePositions: Set<string> // Set of "x,y" strings for visible tiles
}

export function MalwareLayer({ malware, tileSize, visiblePositions }: MalwareLayerProps) {
  return (
    <>
      {malware
        .filter(m => m.status !== 'destroyed')
        .map(m => {
          const posKey = `${m.position.x},${m.position.y}`
          const isVisible = visiblePositions.has(posKey)

          return <MalwareSprite key={m.id} malware={m} tileSize={tileSize} isVisible={isVisible} />
        })}
    </>
  )
}
